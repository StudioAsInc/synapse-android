package com.synapse.social.studioasinc.groupchat.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import androidx.paging.cachedIn
import com.synapse.social.studioasinc.groupchat.data.model.*
import com.synapse.social.studioasinc.groupchat.data.repository.GroupRepository
import com.synapse.social.studioasinc.groupchat.data.repository.MessageRepository
import com.synapse.social.studioasinc.groupchat.data.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.io.File
import java.util.*
import javax.inject.Inject

@HiltViewModel
class GroupChatViewModel @Inject constructor(
    private val messageRepository: MessageRepository,
    private val groupRepository: GroupRepository,
    private val userRepository: UserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(GroupChatUiState())
    val uiState: StateFlow<GroupChatUiState> = _uiState.asStateFlow()

    private var _groupId: String = ""
    val groupId: String get() = _groupId

    private var currentUser: User? = null
    private var currentGroup: Group? = null
    private var currentMember: GroupMember? = null

    fun initialize(groupId: String) {
        _groupId = groupId
        loadInitialData()
        startMessageListener()
    }

    val messagesPagingData: Flow<PagingData<GroupMessage>> by lazy {
        messageRepository.getGroupMessagesPaged(_groupId).cachedIn(viewModelScope)
    }

    val groupMembersFlow: Flow<List<GroupMember>> by lazy {
        groupRepository.getGroupMembersFlow(_groupId)
    }

    val groupFlow: Flow<Group?> by lazy {
        groupRepository.getGroupByIdFlow(_groupId)
    }

    private fun loadInitialData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // Load current user
                currentUser = userRepository.getCurrentUser().getOrNull()
                
                // Load group
                val groupResult = groupRepository.getGroupById(_groupId)
                currentGroup = groupResult.getOrNull()
                
                // Load current user's membership
                if (currentUser != null) {
                    val memberResult = groupRepository.getGroupMember(_groupId, currentUser!!.id)
                    currentMember = memberResult.getOrNull()
                }
                
                // Sync messages
                messageRepository.syncMessages(_groupId)
                
                // Mark messages as seen
                if (currentUser != null) {
                    messageRepository.markMessagesAsSeen(_groupId, currentUser!!.id)
                }
                
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        currentUserRole = currentMember?.getUserRole() ?: UserRole.MEMBER,
                        canSendMessages = canUserSendMessages(),
                        error = null
                    )
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "Failed to load chat data"
                    )
                }
            }
        }
    }

    private fun startMessageListener() {
        viewModelScope.launch {
            messageRepository.startListeningToMessages(_groupId).collect { message ->
                // Message received via real-time listener
                // UI will automatically update via PagingData
                
                // Mark as seen if not from current user
                if (currentUser != null && message.senderId != currentUser!!.id) {
                    messageRepository.markMessageAsSeen(message.id, currentUser!!.id)
                }
            }
        }
    }

    fun sendMessage(text: String) {
        if (text.trim().isEmpty() || currentUser == null) return
        
        viewModelScope.launch {
            val message = GroupMessage(
                id = "", // Will be generated by repository
                groupId = _groupId,
                text = text.trim(),
                timestamp = System.currentTimeMillis(),
                localId = UUID.randomUUID().toString()
            )
            
            messageRepository.sendMessage(message).fold(
                onSuccess = { messageId ->
                    // Message sent successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to send message")
                    }
                }
            )
        }
    }

    fun sendMessageWithAttachments(text: String, attachmentFiles: List<File>) {
        if (currentUser == null) return
        
        viewModelScope.launch {
            _uiState.update { it.copy(isUploadingAttachment = true) }
            
            val message = GroupMessage(
                id = "",
                groupId = _groupId,
                text = text.trim(),
                timestamp = System.currentTimeMillis(),
                localId = UUID.randomUUID().toString()
            )
            
            messageRepository.sendMessageWithAttachments(message, attachmentFiles).fold(
                onSuccess = { messageId ->
                    _uiState.update { it.copy(isUploadingAttachment = false) }
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(
                            isUploadingAttachment = false,
                            error = exception.message ?: "Failed to send message with attachments"
                        )
                    }
                }
            )
        }
    }

    fun editMessage(messageId: String, newText: String) {
        viewModelScope.launch {
            messageRepository.editMessage(messageId, newText).fold(
                onSuccess = {
                    // Message edited successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to edit message")
                    }
                }
            )
        }
    }

    fun deleteMessage(messageId: String, isHardDelete: Boolean = false) {
        viewModelScope.launch {
            messageRepository.deleteMessage(messageId, isHardDelete).fold(
                onSuccess = {
                    // Message deleted successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to delete message")
                    }
                }
            )
        }
    }

    fun addReaction(messageId: String, emoji: String) {
        if (currentUser == null) return
        
        viewModelScope.launch {
            messageRepository.addReaction(messageId, currentUser!!.id, emoji).fold(
                onSuccess = {
                    // Reaction added successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to add reaction")
                    }
                }
            )
        }
    }

    fun removeReaction(messageId: String, emoji: String) {
        if (currentUser == null) return
        
        viewModelScope.launch {
            messageRepository.removeReaction(messageId, currentUser!!.id, emoji).fold(
                onSuccess = {
                    // Reaction removed successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to remove reaction")
                    }
                }
            )
        }
    }

    fun replyToMessage(originalMessageId: String, replyText: String) {
        if (replyText.trim().isEmpty() || currentUser == null) return
        
        viewModelScope.launch {
            val replyMessage = GroupMessage(
                id = "",
                groupId = _groupId,
                text = replyText.trim(),
                timestamp = System.currentTimeMillis(),
                replyToMessageId = originalMessageId,
                localId = UUID.randomUUID().toString()
            )
            
            messageRepository.replyToMessage(originalMessageId, replyMessage).fold(
                onSuccess = { messageId ->
                    // Reply sent successfully
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Failed to send reply")
                    }
                }
            )
        }
    }

    fun searchMessages(query: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isSearching = true) }
            
            messageRepository.searchMessages(_groupId, query).fold(
                onSuccess = { messages ->
                    _uiState.update { 
                        it.copy(
                            searchResults = messages,
                            isSearching = false
                        )
                    }
                },
                onFailure = { exception ->
                    _uiState.update { 
                        it.copy(
                            isSearching = false,
                            error = exception.message ?: "Search failed"
                        )
                    }
                }
            )
        }
    }

    fun clearSearch() {
        _uiState.update { 
            it.copy(
                searchResults = emptyList(),
                isSearching = false
            )
        }
    }

    fun startTyping() {
        // Implement typing indicator
    }

    fun stopTyping() {
        // Implement typing indicator
    }

    fun retryFailedMessages() {
        viewModelScope.launch {
            messageRepository.retryFailedMessages(_groupId)
        }
    }

    private fun canUserSendMessages(): Boolean {
        val group = currentGroup ?: return false
        val member = currentMember ?: return false
        
        return if (group.settings.onlyAdminsCanMessage) {
            member.getUserRole().canManageMembers()
        } else {
            true
        }
    }

    fun canUserDeleteMessage(message: GroupMessage): Boolean {
        val user = currentUser ?: return false
        val member = currentMember ?: return false
        
        return message.canBeDeletedBy(user.id, member.getUserRole())
    }

    fun canUserEditMessage(message: GroupMessage): Boolean {
        val user = currentUser ?: return false
        return message.canBeEditedBy(user.id)
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }

    override fun onCleared() {
        super.onCleared()
        messageRepository.stopListeningToMessages(_groupId)
    }
}

data class GroupChatUiState(
    val isLoading: Boolean = false,
    val isSearching: Boolean = false,
    val isUploadingAttachment: Boolean = false,
    val currentUserRole: UserRole = UserRole.MEMBER,
    val canSendMessages: Boolean = true,
    val searchResults: List<GroupMessage> = emptyList(),
    val error: String? = null
)